<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1400">
    <title>Sistema de An치lisis de Decisiones</title>
    
    <!-- D3.js para visualizaci칩n del 치rbol -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Chart.js para gr치ficos de sensibilidad -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Math.js para c치lculos -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            padding: 20px;
        }
        
        .input-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            height: fit-content;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        
        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .section:last-child {
            border-bottom: none;
        }
        
        .section-title {
            color: #667eea;
            font-size: 1.2em;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 14px;
            transition: all 0.3s;
            margin-bottom: 10px;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s;
            margin-right: 10px;
            margin-top: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .output-panel {
            background: white;
            padding: 20px;
            border-radius: 10px;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
        }
        
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .matrix-input {
            display: grid;
            gap: 10px;
            margin-top: 10px;
        }
        
        .matrix-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 5px;
        }
        
        .matrix-cell {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
        }
        
        .result-box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .result-title {
            color: #667eea;
            font-size: 1.3em;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .result-value {
            font-size: 1.5em;
            color: #333;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .decision-highlight {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        #tree-container {
            width: 100%;
            height: 700px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            overflow: auto;
            background: #fafafa;
            position: relative;
        }
        
        #tree-container svg {
            width: 100%;
            height: 100%;
        }
        
        .node {
            cursor: pointer;
        }
        
        .node circle {
            fill: #fff;
            stroke: #667eea;
            stroke-width: 3px;
        }
        
        .node rect {
            fill: #667eea;
            stroke: #764ba2;
            stroke-width: 2px;
        }
        
        .node text {
            font-size: 12px;
            font-weight: 500;
        }
        
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 2px;
        }
        
        .prob-label {
            font-size: 11px;
            fill: #666;
        }
        
        .value-label {
            font-size: 13px;
            fill: #333;
            font-weight: bold;
        }
        
        #sensitivity-chart {
            max-width: 100%;
            height: 400px;
        }
        
        .bayes-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .bayes-table th,
        .bayes-table td {
            padding: 12px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        .bayes-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
        }
        
        .bayes-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .bayes-table tr:hover {
            background: #e8eaf6;
        }
        
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .warning-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .success-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .hidden {
            display: none;
        }
        
        .study-section {
            background: #f0f4ff;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }
        
        .prob-input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>游꿢 Sistema de An치lisis de Decisiones</h1>
            <p class="subtitle">Herramienta completa para teor칤a de decisiones con 치rboles, an치lisis de sensibilidad y c치lculo bayesiano</p>
        </header>
        
        <div class="main-content">
            <div class="input-panel">
                <div class="section">
                    <h2 class="section-title">丘뙖잺 Configuraci칩n General</h2>
                    
                    <label for="objective">Objetivo:</label>
                    <select id="objective">
                        <option value="max">Maximizar</option>
                        <option value="min">Minimizar</option>
                    </select>
                    
                    <label for="numActions">N칰mero de Cursos de Acci칩n:</label>
                    <input type="number" id="numActions" min="2" value="3">
                    
                    <label for="numStates">N칰mero de Estados de Naturaleza:</label>
                    <input type="number" id="numStates" min="2" value="3">
                    
                    <button onclick="setupMatrix()">Configurar Matriz</button>
                </div>
                
                <div class="section">
                    <h2 class="section-title">游늵 Datos de Entrada</h2>
                    
                    <div id="actionNames"></div>
                    <div id="stateNames"></div>
                    <div id="matrixContainer"></div>
                    <div id="probabilities"></div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">游 Criterio de Decisi칩n</h2>
                    
                    <label for="decisionCriterion">Tipo de Decisi칩n:</label>
                    <select id="decisionCriterion" onchange="updateCriterionOptions()">
                        <option value="certainty">Certeza</option>
                        <option value="uncertainty">Incertidumbre</option>
                        <option value="risk">Riesgo</option>
                    </select>
                    
                    <div id="uncertaintyOptions" class="hidden">
                        <label for="uncertaintyCriterion">Criterio bajo Incertidumbre:</label>
                        <select id="uncertaintyCriterion">
                            <option value="laplace">Laplace (Equiprobabilidad)</option>
                            <option value="pessimist">Pesimista (Maximin/Minimax)</option>
                            <option value="optimist">Optimista (Maximax/Minimin)</option>
                            <option value="hurwicz">Hurwicz</option>
                            <option value="savage">Savage (Costo de Oportunidad)</option>
                        </select>
                        
                        <div id="hurwiczAlpha" class="hidden">
                            <label for="alphaValue">Coeficiente 풤 (Hurwicz):</label>
                            <input type="number" id="alphaValue" min="0" max="1" step="0.1" value="0.5">
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">游댧 Estudio Adicional</h2>
                    
                    <label for="hasStudy">쮺onsiderar estudio adicional?</label>
                    <select id="hasStudy" onchange="toggleStudyOptions()">
                        <option value="no">No</option>
                        <option value="yes">S칤</option>
                    </select>
                    
                    <div id="studyOptions" class="hidden study-section">
                        <label for="studyCost">Costo del Estudio:</label>
                        <input type="number" id="studyCost" value="1000">
                        
                        <label for="numStudyResults">N칰mero de Resultados del Estudio:</label>
                        <input type="number" id="numStudyResults" min="2" value="2">
                        
                        <button onclick="setupStudyProbabilities()">Configurar Probabilidades del Estudio</button>
                        
                        <div id="studyProbContainer"></div>
                    </div>
                </div>
                
                <div class="section">
                    <button onclick="calculateAll()" style="width: 100%; background: linear-gradient(135deg, #4caf50 0%, #8bc34a 100%);">
                        游늳 Calcular Todo
                    </button>
                </div>
            </div>
            
            <div class="output-panel">
                <div class="tabs">
                    <button class="tab active" onclick="showTab('results')">游늵 Resultados</button>
                    <button class="tab" onclick="showTab('tree')">游꺕 츼rbol de Decisi칩n</button>
                    <button class="tab" onclick="showTab('sensitivity')">游늴 An치lisis de Sensibilidad</button>
                    <button class="tab" onclick="showTab('bayes')">游빑 An치lisis Bayesiano</button>
                </div>
                
                <div id="results" class="tab-content active">
                    <div id="resultsContent">
                        <div class="info-box">
                            <p>Configure los par치metros y haga clic en "Calcular Todo" para ver los resultados.</p>
                        </div>
                    </div>
                </div>
                
                <div id="tree" class="tab-content">
                    <div id="tree-container"></div>
                </div>
                
                <div id="sensitivity" class="tab-content">
                    <canvas id="sensitivity-chart"></canvas>
                    <div id="sensitivityAnalysis"></div>
                </div>
                
                <div id="bayes" class="tab-content">
                    <div id="bayesContent">
                        <div class="info-box">
                            <p>Configure un estudio adicional para ver el an치lisis bayesiano.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Variables globales
        let actions = [];
        let states = [];
        let payoffMatrix = [];
        let stateProbabilities = [];
        let studyResults = [];
        let studyConditionalProbs = [];
        let decisionTree = null;
        let sensitivityChart = null;
        
        // Inicializaci칩n
        window.onload = function() {
            setupMatrix();
            updateCriterionOptions();
        };
        
        // Configurar matriz de pagos
        function setupMatrix() {
            const numActions = parseInt(document.getElementById('numActions').value);
            const numStates = parseInt(document.getElementById('numStates').value);
            
            // Inicializar arrays
            actions = Array(numActions).fill(null).map((_, i) => `Acci칩n ${i + 1}`);
            states = Array(numStates).fill(null).map((_, i) => `Estado ${i + 1}`);
            payoffMatrix = Array(numActions).fill(null).map(() => Array(numStates).fill(0));
            stateProbabilities = Array(numStates).fill(1/numStates);
            
            // Crear inputs para nombres de acciones
            let actionHTML = '<label>Nombres de Acciones:</label>';
            for (let i = 0; i < numActions; i++) {
                actionHTML += `<input type="text" id="action_${i}" value="Acci칩n ${i + 1}" onchange="updateActionName(${i}, this.value)">`;
            }
            document.getElementById('actionNames').innerHTML = actionHTML;
            
            // Crear inputs para nombres de estados
            let stateHTML = '<label>Nombres de Estados:</label>';
            for (let i = 0; i < numStates; i++) {
                stateHTML += `<input type="text" id="state_${i}" value="Estado ${i + 1}" onchange="updateStateName(${i}, this.value)">`;
            }
            document.getElementById('stateNames').innerHTML = stateHTML;
            
            // Crear matriz de pagos
            let matrixHTML = '<label>Matriz de Pagos/Costos:</label><div class="matrix-input">';
            
            // Encabezados
            matrixHTML += '<div class="matrix-row"><div class="matrix-cell"></div>';
            for (let j = 0; j < numStates; j++) {
                matrixHTML += `<div class="matrix-cell" style="background: #e8eaf6; font-weight: bold;">E${j + 1}</div>`;
            }
            matrixHTML += '</div>';
            
            // Filas
            for (let i = 0; i < numActions; i++) {
                matrixHTML += '<div class="matrix-row">';
                matrixHTML += `<div class="matrix-cell" style="background: #e8eaf6; font-weight: bold;">A${i + 1}</div>`;
                for (let j = 0; j < numStates; j++) {
                    matrixHTML += `<input type="number" class="matrix-cell" id="cell_${i}_${j}" value="0" onchange="updateMatrix(${i}, ${j}, this.value)">`;
                }
                matrixHTML += '</div>';
            }
            matrixHTML += '</div>';
            document.getElementById('matrixContainer').innerHTML = matrixHTML;
            
            // Crear inputs para probabilidades (solo si es decisi칩n bajo riesgo)
            updateProbabilities();
        }
        
        function updateProbabilities() {
            const criterion = document.getElementById('decisionCriterion').value;
            const numStates = parseInt(document.getElementById('numStates').value);
            
            if (criterion === 'risk') {
                let probHTML = '<label>Probabilidades de Estados:</label><div class="prob-input-grid">';
                for (let i = 0; i < numStates; i++) {
                    probHTML += `
                        <div>
                            <label style="font-size: 12px;">P(${states[i] || 'Estado ' + (i + 1)}):</label>
                            <input type="number" id="prob_${i}" min="0" max="1" step="0.01" value="${(1/numStates).toFixed(2)}" onchange="updateStateProbability(${i}, this.value)">
                        </div>
                    `;
                }
                probHTML += '</div>';
                probHTML += '<div class="warning-box" id="probWarning" style="display: none;">丘멆잺 La suma de probabilidades debe ser 1.0</div>';
                document.getElementById('probabilities').innerHTML = probHTML;
            } else {
                document.getElementById('probabilities').innerHTML = '';
            }
        }
        
        function updateActionName(index, value) {
            actions[index] = value;
        }
        
        function updateStateName(index, value) {
            states[index] = value;
        }
        
        function updateMatrix(i, j, value) {
            payoffMatrix[i][j] = parseFloat(value) || 0;
        }
        
        function updateStateProbability(index, value) {
            stateProbabilities[index] = parseFloat(value) || 0;
            
            // Verificar que la suma sea 1
            const sum = stateProbabilities.reduce((a, b) => a + b, 0);
            const warning = document.getElementById('probWarning');
            if (warning) {
                if (Math.abs(sum - 1) > 0.01) {
                    warning.style.display = 'block';
                    warning.innerHTML = `丘멆잺 La suma de probabilidades es ${sum.toFixed(2)}. Debe ser 1.0`;
                } else {
                    warning.style.display = 'none';
                }
            }
        }
        
        function updateCriterionOptions() {
            const criterion = document.getElementById('decisionCriterion').value;
            const uncertaintyOptions = document.getElementById('uncertaintyOptions');
            const uncertaintyCriterion = document.getElementById('uncertaintyCriterion');
            
            if (criterion === 'uncertainty') {
                uncertaintyOptions.classList.remove('hidden');
            } else {
                uncertaintyOptions.classList.add('hidden');
            }
            
            if (criterion === 'risk') {
                updateProbabilities();
            } else {
                document.getElementById('probabilities').innerHTML = '';
            }
            
            // Mostrar/ocultar alpha para Hurwicz
            uncertaintyCriterion.addEventListener('change', function() {
                const hurwiczAlpha = document.getElementById('hurwiczAlpha');
                if (this.value === 'hurwicz') {
                    hurwiczAlpha.classList.remove('hidden');
                } else {
                    hurwiczAlpha.classList.add('hidden');
                }
            });
        }
        
        function toggleStudyOptions() {
            const hasStudy = document.getElementById('hasStudy').value;
            const studyOptions = document.getElementById('studyOptions');
            
            if (hasStudy === 'yes') {
                studyOptions.classList.remove('hidden');
            } else {
                studyOptions.classList.add('hidden');
            }
        }
        
        function setupStudyProbabilities() {
            const numStates = parseInt(document.getElementById('numStates').value);
            const numResults = parseInt(document.getElementById('numStudyResults').value);
            
            studyResults = Array(numResults).fill(null).map((_, i) => `Resultado ${i + 1}`);
            studyConditionalProbs = Array(numResults).fill(null).map(() => Array(numStates).fill(1/numResults));
            
            let html = '<label>Probabilidades Condicionales P(Resultado|Estado):</label>';
            html += '<table class="bayes-table" style="margin-top: 10px;">';
            html += '<tr><th>Resultado\\Estado</th>';
            
            for (let j = 0; j < numStates; j++) {
                html += `<th>${states[j]}</th>`;
            }
            html += '</tr>';
            
            for (let i = 0; i < numResults; i++) {
                html += `<tr><td><input type="text" value="Resultado ${i + 1}" id="result_${i}" style="width: 100px;" onchange="studyResults[${i}] = this.value"></td>`;
                for (let j = 0; j < numStates; j++) {
                    html += `<td><input type="number" min="0" max="1" step="0.01" value="${(1/numResults).toFixed(2)}" id="studyprob_${i}_${j}" style="width: 80px;" onchange="studyConditionalProbs[${i}][${j}] = parseFloat(this.value)"></td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            
            document.getElementById('studyProbContainer').innerHTML = html;
        }
        
        function showTab(tabName) {
            // Actualizar tabs activos
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
        
        function calculateAll() {
            try {
                // Validar datos
                if (!validateInputs()) {
                    return;
                }
                
                // Calcular resultados seg칰n criterio
                const results = calculateDecision();
                displayResults(results);
                
                // Generar 치rbol de decisi칩n
                generateDecisionTree(results);
                
                // An치lisis de sensibilidad (solo para riesgo)
                if (document.getElementById('decisionCriterion').value === 'risk') {
                    performSensitivityAnalysis();
                }
                
                // An치lisis bayesiano (si hay estudio)
                if (document.getElementById('hasStudy').value === 'yes') {
                    performBayesianAnalysis();
                }
                
                // Cambiar a tab de resultados
                document.querySelector('.tab').click();
                
            } catch (error) {
                console.error('Error en c치lculos:', error);
                alert('Error al realizar los c치lculos. Verifique los datos ingresados.');
            }
        }
        
        function validateInputs() {
            // Validar matriz
            for (let i = 0; i < payoffMatrix.length; i++) {
                for (let j = 0; j < payoffMatrix[i].length; j++) {
                    if (isNaN(payoffMatrix[i][j])) {
                        alert(`Valor inv치lido en la matriz en posici칩n [${i + 1}, ${j + 1}]`);
                        return false;
                    }
                }
            }
            
            // Validar probabilidades si es decisi칩n bajo riesgo
            if (document.getElementById('decisionCriterion').value === 'risk') {
                const sum = stateProbabilities.reduce((a, b) => a + b, 0);
                if (Math.abs(sum - 1) > 0.01) {
                    alert('La suma de probabilidades debe ser 1.0');
                    return false;
                }
            }
            
            return true;
        }
        
        function calculateDecision() {
            const objective = document.getElementById('objective').value;
            const criterion = document.getElementById('decisionCriterion').value;
            let results = {
                criterion: criterion,
                objective: objective,
                actions: actions,
                states: states,
                matrix: payoffMatrix,
                decision: null,
                values: [],
                explanation: ''
            };
            
            switch (criterion) {
                case 'certainty':
                    results = calculateCertainty(results);
                    break;
                case 'uncertainty':
                    const subCriterion = document.getElementById('uncertaintyCriterion').value;
                    results = calculateUncertainty(results, subCriterion);
                    break;
                case 'risk':
                    results = calculateRisk(results);
                    break;
            }
            
            return results;
        }
        
        function calculateCertainty(results) {
            // En certeza, asumimos que conocemos qu칠 estado ocurrir치
            // Por simplicidad, tomamos el primer estado
            results.values = payoffMatrix.map(row => row[0]);
            
            if (results.objective === 'max') {
                const maxVal = Math.max(...results.values);
                results.decision = actions[results.values.indexOf(maxVal)];
                results.optimalValue = maxVal;
            } else {
                const minVal = Math.min(...results.values);
                results.decision = actions[results.values.indexOf(minVal)];
                results.optimalValue = minVal;
            }
            
            results.explanation = `Bajo certeza, conociendo que ocurrir치 ${states[0]}, la mejor decisi칩n es ${results.decision} con valor ${results.optimalValue}`;
            return results;
        }
        
        function calculateUncertainty(results, subCriterion) {
            const objective = results.objective;
            
            switch (subCriterion) {
                case 'laplace':
                    // Criterio de Laplace - equiprobabilidad
                    results.values = payoffMatrix.map(row => 
                        row.reduce((sum, val) => sum + val, 0) / row.length
                    );
                    results.explanation = 'Criterio de Laplace: Se asume equiprobabilidad para todos los estados.';
                    break;
                    
                case 'pessimist':
                    // Criterio Pesimista (Maximin/Minimax)
                    if (objective === 'max') {
                        results.values = payoffMatrix.map(row => Math.min(...row));
                        results.explanation = 'Criterio Maximin: Se elige el m치ximo de los m칤nimos.';
                    } else {
                        results.values = payoffMatrix.map(row => Math.max(...row));
                        results.explanation = 'Criterio Minimax: Se elige el m칤nimo de los m치ximos.';
                    }
                    break;
                    
                case 'optimist':
                    // Criterio Optimista (Maximax/Minimin)
                    if (objective === 'max') {
                        results.values = payoffMatrix.map(row => Math.max(...row));
                        results.explanation = 'Criterio Maximax: Se elige el m치ximo de los m치ximos.';
                    } else {
                        results.values = payoffMatrix.map(row => Math.min(...row));
                        results.explanation = 'Criterio Minimin: Se elige el m칤nimo de los m칤nimos.';
                    }
                    break;
                    
                case 'hurwicz':
                    // Criterio de Hurwicz
                    const alpha = parseFloat(document.getElementById('alphaValue').value);
                    if (objective === 'max') {
                        results.values = payoffMatrix.map(row => {
                            const max = Math.max(...row);
                            const min = Math.min(...row);
                            return alpha * max + (1 - alpha) * min;
                        });
                    } else {
                        results.values = payoffMatrix.map(row => {
                            const max = Math.max(...row);
                            const min = Math.min(...row);
                            return alpha * min + (1 - alpha) * max;
                        });
                    }
                    results.explanation = `Criterio de Hurwicz con 풤=${alpha}: Combinaci칩n ponderada entre optimismo y pesimismo.`;
                    break;
                    
                case 'savage':
                    // Criterio de Savage (Costo de Oportunidad)
                    const regretMatrix = calculateRegretMatrix(payoffMatrix, objective);
                    results.values = regretMatrix.map(row => Math.max(...row));
                    results.regretMatrix = regretMatrix;
                    results.explanation = 'Criterio de Savage: Se minimiza el m치ximo arrepentimiento.';
                    
                    // Para Savage, siempre minimizamos el arrepentimiento
                    const minRegret = Math.min(...results.values);
                    results.decision = actions[results.values.indexOf(minRegret)];
                    results.optimalValue = minRegret;
                    return results;
            }
            
            // Seleccionar la mejor acci칩n
            if (objective === 'max') {
                const maxVal = Math.max(...results.values);
                results.decision = actions[results.values.indexOf(maxVal)];
                results.optimalValue = maxVal;
            } else {
                const minVal = Math.min(...results.values);
                results.decision = actions[results.values.indexOf(minVal)];
                results.optimalValue = minVal;
            }
            
            return results;
        }
        
        function calculateRegretMatrix(matrix, objective) {
            const numActions = matrix.length;
            const numStates = matrix[0].length;
            const regretMatrix = [];
            
            for (let j = 0; j < numStates; j++) {
                const column = matrix.map(row => row[j]);
                const best = objective === 'max' ? Math.max(...column) : Math.min(...column);
                
                for (let i = 0; i < numActions; i++) {
                    if (!regretMatrix[i]) regretMatrix[i] = [];
                    regretMatrix[i][j] = objective === 'max' ? 
                        best - matrix[i][j] : 
                        matrix[i][j] - best;
                }
            }
            
            return regretMatrix;
        }
        
        function calculateRisk(results) {
            // Decisi칩n bajo riesgo - Valor esperado
            results.probabilities = stateProbabilities;
            results.values = payoffMatrix.map(row => {
                let expectedValue = 0;
                for (let j = 0; j < row.length; j++) {
                    expectedValue += row[j] * stateProbabilities[j];
                }
                return expectedValue;
            });
            
            if (results.objective === 'max') {
                const maxVal = Math.max(...results.values);
                results.decision = actions[results.values.indexOf(maxVal)];
                results.optimalValue = maxVal;
            } else {
                const minVal = Math.min(...results.values);
                results.decision = actions[results.values.indexOf(minVal)];
                results.optimalValue = minVal;
            }
            
            // Calcular VEIP (Valor Esperado de Informaci칩n Perfecta)
            let veip = 0;
            for (let j = 0; j < states.length; j++) {
                const column = payoffMatrix.map(row => row[j]);
                const best = results.objective === 'max' ? Math.max(...column) : Math.min(...column);
                veip += best * stateProbabilities[j];
            }
            
            results.veip = veip;
            results.evpi = Math.abs(veip - results.optimalValue); // Valor Esperado de Informaci칩n Perfecta
            results.explanation = `Decisi칩n bajo riesgo: Se usa el valor esperado. VEIP=${veip.toFixed(2)}, EVPI=${results.evpi.toFixed(2)}`;
            
            return results;
        }
        
        function displayResults(results) {
            let html = '<div class="result-box">';
            html += `<h3 class="result-title">游늵 Resultados del An치lisis</h3>`;
            html += `<p><strong>Criterio:</strong> ${results.criterion}</p>`;
            html += `<p><strong>Objetivo:</strong> ${results.objective === 'max' ? 'Maximizar' : 'Minimizar'}</p>`;
            html += `<p>${results.explanation}</p>`;
            html += '</div>';
            
            // Mostrar matriz de pagos
            html += '<div class="result-box">';
            html += '<h3 class="result-title">Matriz de Pagos</h3>';
            html += '<table class="bayes-table">';
            html += '<tr><th>Acci칩n\\Estado</th>';
            for (let state of states) {
                html += `<th>${state}</th>`;
            }
            if (results.criterion === 'risk') {
                html += '<th>Valor Esperado</th>';
            }
            html += '</tr>';
            
            for (let i = 0; i < actions.length; i++) {
                html += `<tr><td><strong>${actions[i]}</strong></td>`;
                for (let j = 0; j < states.length; j++) {
                    html += `<td>${payoffMatrix[i][j]}</td>`;
                }
                if (results.values[i] !== undefined) {
                    html += `<td style="background: #e8eaf6;"><strong>${results.values[i].toFixed(2)}</strong></td>`;
                }
                html += '</tr>';
            }
            
            if (results.criterion === 'risk' && results.probabilities) {
                html += '<tr><td><strong>P(Estado)</strong></td>';
                for (let prob of results.probabilities) {
                    html += `<td>${prob.toFixed(2)}</td>`;
                }
                html += '<td></td></tr>';
            }
            html += '</table>';
            html += '</div>';
            
            // Matriz de arrepentimiento para Savage
            if (results.regretMatrix) {
                html += '<div class="result-box">';
                html += '<h3 class="result-title">Matriz de Arrepentimiento (Savage)</h3>';
                html += '<table class="bayes-table">';
                html += '<tr><th>Acci칩n\\Estado</th>';
                for (let state of states) {
                    html += `<th>${state}</th>`;
                }
                html += '<th>Max Arrepentimiento</th></tr>';
                
                for (let i = 0; i < actions.length; i++) {
                    html += `<tr><td><strong>${actions[i]}</strong></td>`;
                    for (let j = 0; j < states.length; j++) {
                        html += `<td>${results.regretMatrix[i][j].toFixed(2)}</td>`;
                    }
                    html += `<td style="background: #e8eaf6;"><strong>${results.values[i].toFixed(2)}</strong></td>`;
                    html += '</tr>';
                }
                html += '</table>';
                html += '</div>';
            }
            
            // Decisi칩n 칩ptima
            html += '<div class="decision-highlight">';
            html += '<h3 style="margin-bottom: 10px;">游꿢 Decisi칩n 칍ptima</h3>';
            html += `<p class="result-value">${results.decision}</p>`;
            html += `<p>Valor 칩ptimo: ${results.optimalValue.toFixed(2)}</p>`;
            
            if (results.evpi !== undefined) {
                html += `<p>VEIP: ${results.veip.toFixed(2)} | EVPI: ${results.evpi.toFixed(2)}</p>`;
            }
            html += '</div>';
            
            document.getElementById('resultsContent').innerHTML = html;
        }
        
        function generateDecisionTree(results) {
            // Limpiar el contenedor
            const container = document.getElementById('tree-container');
            container.innerHTML = '';
            
            // Preparar datos para el 치rbol
            const treeData = buildTreeData(results);
            
            // Calcular dimensiones din치micamente basadas en el n칰mero de nodos
            const nodeCount = countNodes(treeData);
            const treeDepth = getTreeDepth(treeData);
            
            // Dimensiones adaptativas
            const margin = {top: 50, right: 200, bottom: 50, left: 150};
            const width = Math.max(1200, treeDepth * 300) - margin.left - margin.right;
            const height = Math.max(600, nodeCount * 60) - margin.top - margin.bottom;
            
            // Calcular las dimensiones totales del viewBox
            const svgWidth = width + margin.left + margin.right;
            const svgHeight = height + margin.top + margin.bottom;

            // Crear SVG con viewBox para que sea escalable
            const svg = d3.select('#tree-container')
                .append('svg')
                .attr('viewBox', `0 0 ${svgWidth} ${svgHeight}`) // Define el 치rea de visualizaci칩n
                .attr('preserveAspectRatio', 'xMidYMid meet'); // Asegura que escale correctamente

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Crear layout del 치rbol con mayor separaci칩n
            const tree = d3.tree()
                .size([height, width])
                .separation((a, b) => (a.parent == b.parent ? 1.5 : 2));
            
            const root = d3.hierarchy(treeData);
            tree(root);
            
            // Enlaces con curvas m치s suaves
            g.selectAll('.link')
                .data(root.links())
                .enter().append('path')
                .attr('class', 'link')
                .attr('d', d3.linkHorizontal()
                    .x(d => d.y)
                    .y(d => d.x))
                .style('stroke', '#999')
                .style('stroke-width', '2px')
                .style('fill', 'none');
            
            // Nodos
            const node = g.selectAll('.node')
                .data(root.descendants())
                .enter().append('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.y},${d.x})`);
            
            // A침adir c칤rculos o rect치ngulos seg칰n el tipo de nodo
            node.each(function(d) {
                const selection = d3.select(this);
                
                if (d.data.type === 'decision') {
                    selection.append('rect')
                        .attr('x', -35)
                        .attr('y', -20)
                        .attr('width', 70)
                        .attr('height', 40)
                        .style('fill', '#667eea')
                        .style('stroke', '#fff')
                        .style('stroke-width', '2px');
                } else if (d.data.type === 'chance') {
                    selection.append('circle')
                        .attr('r', 25)
                        .style('fill', '#4caf50')
                        .style('stroke', '#fff')
                        .style('stroke-width', '2px');
                } else {
                    selection.append('rect')
                        .attr('x', -45)
                        .attr('y', -15)
                        .attr('width', 90)
                        .attr('height', 30)
                        .style('fill', '#ff9800')
                        .style('stroke', '#fff')
                        .style('stroke-width', '2px');
                }
            });
            
            // Etiquetas de nodos
            node.append('text')
                .attr('dy', 5)
                .attr('text-anchor', 'middle')
                .style('fill', 'white')
                .style('font-weight', 'bold')
                .style('font-size', '11px')
                .text(d => {
                    // Truncar texto largo
                    const maxLength = 10;
                    const text = d.data.name;
                    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
                });
            
            // Etiquetas de probabilidades en las aristas
            g.selectAll('.prob-label')
                .data(root.links())
                .enter().append('text')
                .attr('class', 'prob-label')
                .attr('x', d => (d.source.y + d.target.y) / 2)
                .attr('y', d => (d.source.x + d.target.x) / 2 - 10)
                .attr('text-anchor', 'middle')
                .style('font-size', '11px')
                .style('fill', '#666')
                .style('background', 'white')
                .text(d => {
                    if (d.target.data.probability !== undefined) {
                        return `P=${d.target.data.probability.toFixed(2)}`;
                    }
                    if (d.target.data.cost !== undefined) {
                        return `C=${d.target.data.cost.toFixed(0)}`;
                    }
                    return '';
                });
            
            // Valores esperados debajo de los nodos
            node.append('text')
                .attr('dy', 40)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .style('fill', '#333')
                .text(d => {
                    if (d.data.value !== undefined && d.data.value !== null) {
                        return `VE=${d.data.value.toFixed(2)}`;
                    }
                    return '';
                });
            
            // A침adir t칤tulo para nodos con nombre completo en tooltip
            node.append('title')
                .text(d => {
                    let tooltip = d.data.name;
                    if (d.data.value !== undefined && d.data.value !== null) {
                        tooltip += `\nValor Esperado: ${d.data.value.toFixed(2)}`;
                    }
                    if (d.data.probability !== undefined) {
                        tooltip += `\nProbabilidad: ${d.data.probability.toFixed(3)}`;
                    }
                    if (d.data.cost !== undefined) {
                        tooltip += `\nCosto: ${d.data.cost.toFixed(2)}`;
                    }
                    return tooltip;
                });
        }
        
        // Funciones auxiliares para contar nodos y profundidad
        function countNodes(node) {
            if (!node.children || node.children.length === 0) {
                return 1;
            }
            return 1 + node.children.reduce((sum, child) => sum + countNodes(child), 0);
        }
        
        function getTreeDepth(node, depth = 0) {
            if (!node.children || node.children.length === 0) {
                return depth;
            }
            return Math.max(...node.children.map(child => getTreeDepth(child, depth + 1)));
        }
        
        function buildTreeData(results) {
            const hasStudy = document.getElementById('hasStudy').value === 'yes';
            
            if (!hasStudy) {
                // 츼rbol simple sin estudio
                return {
                    name: 'Decisi칩n',
                    type: 'decision',
                    value: results.optimalValue,
                    children: actions.map((action, i) => ({
                        name: action,
                        type: 'chance',
                        value: results.values[i],
                        children: states.map((state, j) => ({
                            name: state,
                            type: 'outcome',
                            probability: results.criterion === 'risk' ? stateProbabilities[j] : undefined,
                            value: payoffMatrix[i][j]
                        }))
                    }))
                };
            } else {
                // 츼rbol con estudio adicional
                const studyCost = parseFloat(document.getElementById('studyCost').value);
                
                // Calcular el valor esperado con informaci칩n del estudio
                let expectedValueWithInfo = 0;
                const studyBranches = [];
                
                // Para cada posible resultado del estudio
                for (let r = 0; r < studyResults.length; r++) {
                    // Calcular probabilidad marginal del resultado
                    let marginalProb = 0;
                    for (let s = 0; s < states.length; s++) {
                        marginalProb += studyConditionalProbs[r][s] * stateProbabilities[s];
                    }
                    
                    // Calcular probabilidades posteriores P(Estado|Resultado)
                    const posteriorProbs = [];
                    for (let s = 0; s < states.length; s++) {
                        const posterior = (studyConditionalProbs[r][s] * stateProbabilities[s]) / marginalProb;
                        posteriorProbs.push(posterior);
                    }
                    
                    // Calcular valor esperado de cada acci칩n dado este resultado
                    const actionBranches = [];
                    let bestActionValue = null;
                    let bestActionIndex = -1;
                    
                    for (let a = 0; a < actions.length; a++) {
                        let actionValue = 0;
                        const stateBranches = [];
                        
                        for (let s = 0; s < states.length; s++) {
                            actionValue += payoffMatrix[a][s] * posteriorProbs[s];
                            stateBranches.push({
                                name: states[s],
                                type: 'outcome',
                                probability: posteriorProbs[s],
                                value: payoffMatrix[a][s]
                            });
                        }
                        
                        // Determinar si esta es la mejor acci칩n para este resultado
                        if (bestActionValue === null || 
                            (results.objective === 'max' && actionValue > bestActionValue) ||
                            (results.objective === 'min' && actionValue < bestActionValue)) {
                            bestActionValue = actionValue;
                            bestActionIndex = a;
                        }
                        
                        actionBranches.push({
                            name: actions[a],
                            type: 'chance',
                            value: actionValue,
                            children: stateBranches
                        });
                    }
                    
                    // A침adir el valor de la mejor acci칩n al valor esperado total
                    expectedValueWithInfo += bestActionValue * marginalProb;
                    
                    studyBranches.push({
                        name: studyResults[r],
                        type: 'decision',
                        probability: marginalProb,
                        value: bestActionValue,
                        children: actionBranches
                    });
                }
                
                // Valor neto con estudio (restando el costo)
                const netValueWithStudy = expectedValueWithInfo - studyCost;
                
                return {
                    name: 'Estudio?',
                    type: 'decision',
                    value: Math.max(results.optimalValue, netValueWithStudy),
                    children: [
                        {
                            name: 'Sin Estudio',
                            type: 'chance',
                            value: results.optimalValue,
                            children: actions.map((action, i) => ({
                                name: action,
                                type: 'chance',
                                value: results.values[i],
                                children: states.map((state, j) => ({
                                    name: state,
                                    type: 'outcome',
                                    probability: stateProbabilities[j],
                                    value: payoffMatrix[i][j]
                                }))
                            }))
                        },
                        {
                            name: 'Con Estudio',
                            type: 'chance',
                            value: netValueWithStudy,
                            cost: studyCost,
                            children: studyBranches
                        }
                    ]
                };
            }
        }
        
        function calculateExpectedValueWithStudy(actionIndex, studyResultIndex) {
            let expectedValue = 0;
            const posteriorProbs = calculatePosteriorProbabilities(studyResultIndex);
            
            for (let j = 0; j < states.length; j++) {
                expectedValue += payoffMatrix[actionIndex][j] * posteriorProbs[j];
            }
            
            return expectedValue;
        }
        
        function calculatePosteriorProbabilities(studyResultIndex) {
            // Aplicar teorema de Bayes
            const posteriorProbs = [];
            let marginalProb = 0;
            
            // Calcular P(Resultado)
            for (let j = 0; j < states.length; j++) {
                marginalProb += studyConditionalProbs[studyResultIndex][j] * stateProbabilities[j];
            }
            
            // Calcular P(Estado|Resultado)
            for (let j = 0; j < states.length; j++) {
                const posterior = (studyConditionalProbs[studyResultIndex][j] * stateProbabilities[j]) / marginalProb;
                posteriorProbs.push(posterior);
            }
            
            return posteriorProbs;
        }
        
        function performSensitivityAnalysis() {
            if (states.length !== 2) {
                document.getElementById('sensitivityAnalysis').innerHTML = 
                    '<div class="warning-box">El an치lisis de sensibilidad gr치fico solo est치 disponible para problemas con 2 estados.</div>';
                return;
            }
            
            const objective = document.getElementById('objective').value;
            const numPoints = 100;
            const datasets = [];
            
            // Generar datos para cada acci칩n
            for (let i = 0; i < actions.length; i++) {
                const data = [];
                for (let p = 0; p <= numPoints; p++) {
                    const p1 = p / numPoints;
                    const p2 = 1 - p1;
                    const expectedValue = payoffMatrix[i][0] * p1 + payoffMatrix[i][1] * p2;
                    data.push({x: p1, y: expectedValue});
                }
                
                datasets.push({
                    label: actions[i],
                    data: data,
                    borderColor: `hsl(${i * 360 / actions.length}, 70%, 50%)`,
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0
                });
            }
            
            // Destruir gr치fico anterior si existe
            if (sensitivityChart) {
                sensitivityChart.destroy();
            }
            
            // Crear nuevo gr치fico
            const ctx = document.getElementById('sensitivity-chart').getContext('2d');
            sensitivityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'An치lisis de Sensibilidad',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: `P(${states[0]})`
                            },
                            min: 0,
                            max: 1
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Valor Esperado'
                            }
                        }
                    }
                }
            });
            
            // An치lisis de puntos de indiferencia
            let analysisHTML = '<div class="result-box">';
            analysisHTML += '<h3 class="result-title">Puntos de Indiferencia</h3>';
            
            for (let i = 0; i < actions.length - 1; i++) {
                for (let j = i + 1; j < actions.length; j++) {
                    // Resolver para el punto de indiferencia
                    const a1 = payoffMatrix[i][0] - payoffMatrix[i][1];
                    const b1 = payoffMatrix[i][1];
                    const a2 = payoffMatrix[j][0] - payoffMatrix[j][1];
                    const b2 = payoffMatrix[j][1];
                    
                    if (a1 !== a2) {
                        const p = (b2 - b1) / (a1 - a2);
                        if (p >= 0 && p <= 1) {
                            analysisHTML += `<p>${actions[i]} = ${actions[j]} cuando P(${states[0]}) = ${p.toFixed(3)}</p>`;
                        }
                    }
                }
            }
            
            analysisHTML += '</div>';
            analysisHTML += '<div class="info-box">El gr치fico muestra c칩mo cambia el valor esperado de cada acci칩n seg칰n la probabilidad del primer estado.</div>';
            
            document.getElementById('sensitivityAnalysis').innerHTML = analysisHTML;
        }
        
        function performBayesianAnalysis() {
            const studyCost = parseFloat(document.getElementById('studyCost').value);
            const numStates = states.length;
            const numResults = studyResults.length;
            
            let html = '<div class="result-box">';
            html += '<h3 class="result-title">An치lisis Bayesiano del Estudio</h3>';
            
            // Tabla de probabilidades condicionales
            html += '<h4>Probabilidades Condicionales P(Resultado|Estado)</h4>';
            html += '<table class="bayes-table">';
            html += '<tr><th>Resultado\\Estado</th>';
            for (let state of states) {
                html += `<th>${state}</th>`;
            }
            html += '</tr>';
            
            for (let i = 0; i < numResults; i++) {
                html += `<tr><td><strong>${studyResults[i]}</strong></td>`;
                for (let j = 0; j < numStates; j++) {
                    html += `<td>${studyConditionalProbs[i][j].toFixed(3)}</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            html += '</div>';
            
            // Calcular probabilidades marginales
            html += '<div class="result-box">';
            html += '<h4>Probabilidades Marginales P(Resultado)</h4>';
            const marginalProbs = [];
            
            for (let i = 0; i < numResults; i++) {
                let marginal = 0;
                for (let j = 0; j < numStates; j++) {
                    marginal += studyConditionalProbs[i][j] * stateProbabilities[j];
                }
                marginalProbs.push(marginal);
            }
            
            html += '<table class="bayes-table">';
            html += '<tr>';
            for (let result of studyResults) {
                html += `<th>${result}</th>`;
            }
            html += '</tr><tr>';
            for (let prob of marginalProbs) {
                html += `<td>${prob.toFixed(3)}</td>`;
            }
            html += '</tr></table>';
            html += '</div>';
            
            // Probabilidades a posteriori
            html += '<div class="result-box">';
            html += '<h4>Probabilidades a Posteriori P(Estado|Resultado)</h4>';
            html += '<table class="bayes-table">';
            html += '<tr><th>Estado\\Resultado</th>';
            for (let result of studyResults) {
                html += `<th>${result}</th>`;
            }
            html += '</tr>';
            
            const posteriorProbs = [];
            for (let j = 0; j < numStates; j++) {
                posteriorProbs[j] = [];
                html += `<tr><td><strong>${states[j]}</strong></td>`;
                for (let i = 0; i < numResults; i++) {
                    const posterior = (studyConditionalProbs[i][j] * stateProbabilities[j]) / marginalProbs[i];
                    posteriorProbs[j][i] = posterior;
                    html += `<td>${posterior.toFixed(3)}</td>`;
                }
                html += '</tr>';
            }
            html += '</table>';
            html += '</div>';
            
            // Valor esperado con estudio
            html += '<div class="result-box">';
            html += '<h4>An치lisis del Valor del Estudio</h4>';
            
            const objective = document.getElementById('objective').value;
            let expectedValueWithStudy = 0;
            
            // Tabla de decisiones 칩ptimas por resultado
            html += '<table class="bayes-table">';
            html += '<tr><th>Si el resultado es...</th><th>Decisi칩n 칩ptima</th><th>Valor esperado</th></tr>';
            
            for (let i = 0; i < numResults; i++) {
                // Para cada resultado del estudio, encontrar la mejor acci칩n
                const actionValues = [];
                for (let a = 0; a < actions.length; a++) {
                    let value = 0;
                    for (let s = 0; s < numStates; s++) {
                        value += payoffMatrix[a][s] * posteriorProbs[s][i];
                    }
                    actionValues.push(value);
                }
                
                const bestValue = objective === 'max' ? 
                    Math.max(...actionValues) : 
                    Math.min(...actionValues);
                
                const bestActionIndex = actionValues.indexOf(bestValue);
                const bestAction = actions[bestActionIndex];
                
                expectedValueWithStudy += bestValue * marginalProbs[i];
                
                html += `<tr>`;
                html += `<td>${studyResults[i]} (P=${marginalProbs[i].toFixed(3)})</td>`;
                html += `<td><strong>${bestAction}</strong></td>`;
                html += `<td>${bestValue.toFixed(2)}</td>`;
                html += `</tr>`;
            }
            html += '</table>';
            
            // Comparaci칩n con decisi칩n sin estudio
            const results = calculateDecision();
            const valueWithoutStudy = results.optimalValue;
            const valueOfPerfectInfo = results.evpi || 0;
            const grossValueWithStudy = expectedValueWithStudy;
            const netValueWithStudy = expectedValueWithStudy - studyCost;
            const valueOfStudyInfo = grossValueWithStudy - valueWithoutStudy;
            
            html += '<hr style="margin: 20px 0;">';
            html += '<h4>Resumen de Valores</h4>';
            html += '<table class="bayes-table">';
            html += '<tr><th>Concepto</th><th>Valor</th></tr>';
            html += `<tr><td>Valor esperado SIN estudio</td><td><strong>${valueWithoutStudy.toFixed(2)}</strong></td></tr>`;
            html += `<tr><td>Valor esperado CON estudio (bruto)</td><td><strong>${grossValueWithStudy.toFixed(2)}</strong></td></tr>`;
            html += `<tr><td>Costo del estudio</td><td style="color: red;">-${studyCost.toFixed(2)}</td></tr>`;
            html += `<tr><td>Valor esperado CON estudio (neto)</td><td><strong>${netValueWithStudy.toFixed(2)}</strong></td></tr>`;
            html += `<tr style="background: #e8eaf6;"><td>Valor de la informaci칩n del estudio</td><td><strong>${valueOfStudyInfo.toFixed(2)}</strong></td></tr>`;
            html += `<tr style="background: #e8eaf6;"><td>Valor neto del estudio</td><td><strong>${(valueOfStudyInfo - studyCost).toFixed(2)}</strong></td></tr>`;
            
            if (valueOfPerfectInfo > 0) {
                html += `<tr><td>EVPI (Valor de informaci칩n perfecta)</td><td>${valueOfPerfectInfo.toFixed(2)}</td></tr>`;
                const efficiency = (valueOfStudyInfo / valueOfPerfectInfo * 100).toFixed(1);
                html += `<tr><td>Eficiencia del estudio</td><td>${efficiency}%</td></tr>`;
            }
            html += '</table>';
            html += '</div>';
            
            // Recomendaci칩n
            const netBenefit = valueOfStudyInfo - studyCost;
            if (netBenefit > 0) {
                html += '<div class="success-box">';
                html += `<strong>九 Recomendaci칩n:</strong> S칈 conviene realizar el estudio.`;
                html += `<br>El beneficio neto es de ${netBenefit.toFixed(2)} unidades.`;
                html += `<br>El estudio mejora el valor esperado en ${valueOfStudyInfo.toFixed(2)}, que es mayor que su costo de ${studyCost.toFixed(2)}.`;
                html += '</div>';
            } else if (netBenefit < 0) {
                html += '<div class="warning-box">';
                html += `<strong>丘멆잺 Recomendaci칩n:</strong> NO conviene realizar el estudio.`;
                html += `<br>La p칠rdida neta ser칤a de ${Math.abs(netBenefit).toFixed(2)} unidades.`;
                html += `<br>El estudio solo mejora el valor esperado en ${valueOfStudyInfo.toFixed(2)}, que es menor que su costo de ${studyCost.toFixed(2)}.`;
                html += '</div>';
            } else {
                html += '<div class="info-box">';
                html += `<strong>좶잺 Recomendaci칩n:</strong> Es INDIFERENTE realizar el estudio.`;
                html += `<br>El valor de la informaci칩n iguala exactamente al costo del estudio.`;
                html += '</div>';
            }
            
            document.getElementById('bayesContent').innerHTML = html;
        }
    </script>
</body>
</html>